name: CI-build-image

on:
  push:
    branches:
      - master
  pull_request:
    branches:
      - "**"

jobs:
  workflow-setup:
    runs-on: ubuntu-latest
    outputs:
      GITHUB_REPOSITORY_LOWERCASE: ${{ steps.setouputs.outputs.GITHUB_REPOSITORY_LOWERCASE }}
      BRANCH_NAME: ${{ steps.setouputs.outputs.BRANCH_NAME }}
      DOCKER_TAG_VERSION: ${{ steps.setouputs.outputs.DOCKER_TAG_VERSION }}
      FULL_REPO_SLUG: ${{ steps.setouputs.outputs.FULL_REPO_SLUG }}
      RELEASE_VERSION: ${{ steps.setouputs.outputs.RELEASE_VERSION }}
      CACHE_KEY: ${{ steps.setouputs.outputs.CACHE_KEY }}
    steps:
      - run: echo $GITHUB_REPOSITORY
      - run: echo $GITHUB_REF
      - run: echo $GITHUB_HEAD_REF
      - run: echo $GITHUB_BASE_REF
      - run: echo $GITHUB_WORKSPACE
      - run: echo $GITHUB_EVENT_NAME
      - run: echo $GITHUB_RUN_NUMBER
      - run: echo $GITHUB_RUN_ID
      - name: Git checkout
        uses: actions/checkout@v1
      - name: Set custom env variables
        run: |
          set -x
          GITHUB_REPOSITORY_LOWERCASE=`echo $GITHUB_REPOSITORY | awk '{print tolower($0)}'`
          echo ::set-env name=GITHUB_REPOSITORY_LOWERCASE::$(echo $GITHUB_REPOSITORY_LOWERCASE)

          if [[ -z "$GITHUB_HEAD_REF" ]] # is set only if pipeline run is triggered as pull request
          then
            BRANCH_NAME="${GITHUB_REF#refs/heads/}"
            echo "Setting BRANCH_NAME=$BRANCH_NAME because this pipeline is run as Push"
          else
            BRANCH_NAME=$GITHUB_HEAD_REF
            echo "Setting BRANCH_NAME=$BRANCH_NAME because this pipeline is run as Pull Request"
          fi

          FULL_REPO_SLUG=`echo "${{github.event.pull_request.head.repo.full_name}}" | sed "s/[^[:alnum:]-]//g" | tr '[:upper:]' '[:lower:]'` # lowercase, only alphanumeric and dash
          echo ::set-env name=FULL_REPO_SLUG::$(echo $FULL_REPO_SLUG)

          BRANCH_NAME=`echo $BRANCH_NAME | sed "s/[^[:alnum:]-]//g" | tr '[:upper:]' '[:lower:]'` # lowercase, only alphanumeric and dash
          echo ::set-env name=BRANCH_NAME::$(echo $BRANCH_NAME)

          RELEASE_VERSION=''

          if [[ "${{ github.event_name}}" == "push" && "$BRANCH_NAME" == "master" ]]
          then
            echo "Running push on master branch. Release will happen if version was bumped."

            REPO_VERSION_HIGHEST=$(git describe --tags --always --abbrev=0)
            echo ::set-env name=REPO_VERSION_HIGHEST::$(echo $REPO_VERSION_HIGHEST)
            echo "Highest released version was $REPO_VERSION_HIGHEST"

            REPO_VERSION_DESIRED=`bash ./get-version.sh`
            echo ::set-env name=REPO_VERSION_DESIRED::$(echo $REPO_VERSION_DESIRED)
            echo "Repo declares version $REPO_VERSION_DESIRED"

            if [[ "$REPO_VERSION_HIGHEST" == "$REPO_VERSION_DESIRED" ]]
            then
              DOCKER_TAG_VERSION="$BRANCH_NAME"
              echo "Running push on master but version was not bumped. Will NOT release."
            else
              DOCKER_TAG_VERSION="$BRANCH_NAME"
              RELEASE_VERSION="$REPO_VERSION_DESIRED"
              DOCKER_TAG_VERSION="$REPO_VERSION_DESIRED"
              echo "Running push on master, version was bumped $REPO_VERSION_HIGHEST->$RELEASE_VERSION. Will release $RELEASE_VERSION."
            fi
          else
             DOCKER_TAG_VERSION="$FULL_REPO_SLUG-$BRANCH_NAME"
             echo "This is not push to master. Will NOT release."
          fi

          echo ::set-env name=RELEASE_VERSION::$(echo $RELEASE_VERSION)
          echo ::set-env name=DOCKER_TAG_VERSION::$(echo $DOCKER_TAG_VERSION)
          echo "Docker images built in this CI will be using tag '$DOCKER_TAG_VERSION'"

      - name: Set job outputs
        id: setouputs
        run: |
          set -x
          echo "::set-output name=GITHUB_REPOSITORY_LOWERCASE::$GITHUB_REPOSITORY_LOWERCASE"
          echo "::set-output name=BRANCH_NAME::$BRANCH_NAME"
          echo "::set-output name=DOCKER_TAG_VERSION::$DOCKER_TAG_VERSION"
          echo "::set-output name=FULL_REPO_SLUG::$FULL_REPO_SLUG"
          echo "::set-output name=RELEASE_VERSION::$RELEASE_VERSION"
          echo "::set-output name=CACHE_KEY::$(echo reposlug-$FULL_REPO_SLUG-branch-$BRANCH_NAME-hashfiles-${{ hashFiles('Dockerfile') }})"

  build-image:
    runs-on: ubuntu-latest
    needs:
      - workflow-setup
    steps:
      - name: Load up custom variables
        run: |
          echo ::set-env name=GITHUB_REPOSITORY_LOWERCASE::$(echo ${{needs.workflow-setup.outputs.GITHUB_REPOSITORY_LOWERCASE}})
          echo ::set-env name=BRANCH_NAME::$(echo ${{needs.workflow-setup.outputs.BRANCH_NAME}})
          echo ::set-env name=DOCKER_TAG_VERSION::$(echo ${{needs.workflow-setup.outputs.DOCKER_TAG_VERSION}})
          echo ::set-env name=FULL_REPO_SLUG::$(echo ${{needs.workflow-setup.outputs.FULL_REPO_SLUG}})
          echo ::set-env name=CACHE_KEY::$(echo ${{needs.workflow-setup.outputs.CACHE_KEY}})
      - name: Check cache_key
        run: |
          echo "$CACHE_KEY"
      - name: Git checkout
        uses: actions/checkout@v1
      - name: Try load from cache.
        id: cache-image
        uses: actions/cache@v2
        with:
          path: /tmp/imgcache
          key: $CACHE_KEY
      - name: If FOUND in cache, Print info.
        if: steps.cache-image.outputs.cache-hit != 'true'
        run: |
          echo "CACHE HIT! Key=$CACHE_KEY"
          ls -lah /tmp/imgcache
      - name: If NOT found in cache, Build and cache image.
        if: steps.cache-image.outputs.cache-hit != 'true'
        run: |
          echo "CACHE MISS!"
          set -x
          docker image ls
          docker build -t hello_world:$BRANCH_NAME .
          mkdir -p /tmp/imgcache
          docker save hello_world:$BRANCH_NAME > /tmp/imgcache/hello_world.tar

  run-image:
    runs-on: ubuntu-latest
    needs:
      - build-image
      - workflow-setup
    steps:
      - name: Load up custom variables
        run: |
          echo ::set-env name=GITHUB_REPOSITORY_LOWERCASE::$(echo ${{needs.workflow-setup.outputs.GITHUB_REPOSITORY_LOWERCASE}})
          echo ::set-env name=BRANCH_NAME::$(echo ${{needs.workflow-setup.outputs.BRANCH_NAME}})
          echo ::set-env name=DOCKER_TAG_VERSION::$(echo ${{needs.workflow-setup.outputs.DOCKER_TAG_VERSION}})
          echo ::set-env name=FULL_REPO_SLUG::$(echo ${{needs.workflow-setup.outputs.FULL_REPO_SLUG}})
          echo ::set-env name=CACHE_KEY::$(echo ${{needs.workflow-setup.outputs.CACHE_KEY}})
      - name: Check cache_key
        run: |
          echo "$CACHE_KEY"
      - name: Load image cache.
        id: load-cached-image
        uses: actions/cache@v2
        with:
          path: /tmp/imgcache
          key: $CACHE_KEY
      - name: If no cached image found
        if: steps.load-cached-image.outputs.cache-hit != 'true'
        run: |
          echo "ERROR: Expected to find image from cache $CACHE_KEY"
          exit -1
      - name: Load image
        if: steps.load-cached-image.outputs.cache-hit == 'true'
        run: |
          echo "CACHE HIT: $CACHE_KEY"
          ls -lah /tmp/imgcache/
          docker load < /tmp/imgcache/hello_world.tar
          docker image ls
      - name: Run image!!
        run: |
          set -x
          docker image ls
          docker run hello_world:$BRANCH_NAME





